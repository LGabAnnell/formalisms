\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[margin=3cm, tmargin=2cm, bmargin=2cm]{geometry}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{url}
\usepackage{gensymb}
\usepackage{caption}
\usepackage{subcaption}
\expandafter\def\csname ver@subfig.sty\endcsname{}
\usepackage{subfig}
\usepackage{minted}
\usepackage[hidelinks]{hyperref}
\setminted[java]{tabsize=2}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[l]{\small Lars Gabriel \linebreak Annell Rydenvald}
\fancyhead[c]{
	UNIGE \linebreak
}
\fancyhead[R]{Faculté des Sciences \linebreak Département d'informatique}
\fancyfoot[C]{
	\thepage
}

\lstset{
	basicstyle=\ttfamily
}

\captionsetup[subfigure]{labelformat=empty}


\begin{document}
\begin{center}
	\huge 
	Ardoises \\
	Formalismes et expressions
\end{center}
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage

\section{Introduction}
%Le but de ce travail, dans le cadre du logiciel \underline{\href{https://ardoises.ovh/overview}{Ardoises}}, est d'ajouter des formalismes pour les opérateurs ainsi qu'une manière de transformer 
\section{Ardoises}
% Ecrire à propos d'ardoises, et des autres logiciels qui existent déjà (c.f. présentation)
\section{Formalismes des opérateurs}
% Formalismes des opérateurs
\section{Analyse grammaticale}
Nous avons pensé à deux solutions différentes pour effectuer l'analyse grammaticale:
\begin{enumerate}
	\item[1)] Utiliser des expressions régulières, qui seraient définies par l'utilisateur pour chaque opérateur.
	\item[2)] Générer une grammaire à partir de modèles (patterns) prédéfinis pour différents types d'opérateurs.
\end{enumerate}
J'ai choisi d'utiliser la 2$^{\grave{e}me}$ méthode, car même si les expressions régulières auraient pû être un moyen "plus simple", elles posent un problème: les expressions arithmétiques incluant des parenthèses ne sont pas des langages réguliers, puisqu'on peut, en prenant un exemple simple, se retrouver dans un cas comme celui-ci: $\{(\textquoteleft(\textquoteleft^{n}\textquoteleft)\textquoteleft^{n})^{*}, n \ge 0 \}$
\subsection{Choix de l'outil}
Il existe plusieurs générateurs d'analyseurs lexicaux, tels que: \begin{enumerate}
	\item \underline{\href{http://www.antlr.org/about.html}{ANTLR}}, écrit en Java, générant un analyseur $LL(^*)$
	\item \underline{\href{http://dinosaur.compilertools.net/}{Flex/Bison}}, écrit en C, générant un analyseur $LALR(1)$
	\item \underline{\href{https://pegjs.org/}{PEGjs}}, écrit en JavaScript, générant un parser $PEG$
	\item \underline{\href{https://github.com/LuaDist/lpeg}{LPeg}}, écrit en C, compatible avec Lua, générant un parser $PEG$
	\item \underline{\href{https://github.com/pygy/LuLPeg}{LulPeg}}, implémentation en pur Lua de $LPeg$.
\end{enumerate}
Puisque le projet est écrit en Lua, pour avoir une interopérabilité facile entre les définitions d'opérateurs et expressions, j'ai choisi d'utiliser LPeg. LulPeg a aussi été considéré, cependant celui-ci est beaucoup plus lent que LPeg. \\ \textit{TODO: Include justification.} \\ LPeg, par sa modularité, permet aussi de facilement générer une grammaire à partir des opérateurs définis par l'utilisateur.
\subsection{Algorithme de génération de grammaire}
Puisque nous ne connaissons pas en avance les opérateurs disponibles dans une expression, il est nécessaire de générer la grammaire à partir des opérateurs définis par l'utilisateur. \\
Supposons les opérateurs simples suivants:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
	\hline
	\textbf{Opérateur} & \textbf{Représentation} & \textbf{Priorité} &  \textbf{Type} & \textbf{Associativité}\\ \hline
	Addition & '+' & 11 & binaire & droite \\ \hline
	Soustraction & '-' & 11 & binaire & droite  \\ \hline
	Multiplication & '*' & 12 & binaire & droite  \\ \hline
	Division & '/' & 12 & binaire & droite  \\ \hline
	Exponentiation & '\textasciicircum' & 13 & binaire & droite  \\ \hline
	Négation    & '-'  & 14 & unaire préfixe & N/A  \\ \hline 
  nombre & [0-9]+ & 15 & litéral & N/A \\ \hline
\end{tabular}
\end{center}
Prenons comme base la simple grammaire suivante (qui ne fait rien):
\begin{math}
S \rightarrow S'
% \ \\
% P15 \rightarrow number \ | \ \textrm{'}(\textrm{'} \ S' \ \textrm{'})\textrm{'}
\end{math} \\ \\
On va ensuite rajouter un à un les opérateurs dans cette grammaire, de la manière  suivante:

\begin{enumerate}
	\item On trie la table des opérateurs, par priorité, dans l'ordre décroissant.
	\item Pour chaque type d'opérateur, on crée le pattern. Par exemple, l'opérateur binaire $Addition$ dans notre table, aura le pattern \\ $P11 \rightarrow \ P12 \ \textrm{'}+\textrm{'} \ (P12 \ | \ P11)$
	\item On rajoute le nouveau pattern crée dans la grammaire de base
\end{enumerate}
Pour finir, on se retrouve avec une grammaire comme celle-ci: \\ \\
\begin{math}
S \rightarrow S' \\
S' \rightarrow P11 \\
P11 \rightarrow Addition \ | \ Soustraction \ | \ P12 \\
P12 \rightarrow Division \ | \ Multiplication \ | \ P13 \\
P13 \rightarrow Exponentiation \ | \ P14 \\
P14 \rightarrow N\acute{e}gation \ | \ P15 \\
P15 \rightarrow nombre \ | \ \textrm{'}(\textrm{'} \ S' \ \textrm{'})\textrm{'}
\end{math} \\ \\
Puisque $LPeg$ génère un analyseur lexical de type $PEG$, il faut faire attention à l'ordre de déclaration de la grammaire pour avoir une précédence correcte.

\subsection{Associativité à gauche}
On constate que tous les opérateurs binaires dans le tableau précédent sont associatifs à droite. Or, on voudrait pouvoir préciser l'associativité lors de la déclaration des opérateurs, puisque cela modifie l'arbre syntaxique produit par l'analyseur lexical. Dans le cas d'un analyseur $LR$, l'associativité à gauche se traduit simplement par une récursion à gauche, telle que
\ \\ \\
\begin{math}
Expr \rightarrow Expr \ \textrm{'}+\textrm{'} \ nombre \ | \ nombre
\end{math} \\ \\
Malheureusement, $LPeg$ ne peut pas gérer les récursions à gauche, et une élimination de la récursion à gauche du type
\\ \\
\noindent\begin{math}
	Expr \rightarrow nombre \ Expr\prime \\
	Expr\prime \rightarrow \textrm{'} + \textrm{'} \ Expr\prime \ | \ nombre
\end{math} \\ \\
ne suffit pas. On a encore une associativité à droite. \\
Il existe des implémentations pour introduire la récursion à gauche dans les grammaires $PEG$, telles que \underline{\href{https://github.com/norswap/whimsy/blob/master/doc/autumn/README.md}{Autumn}}\textsuperscript{[1]} ou celle proposée par Laurence Tratt\textsuperscript{[2]}. Puisque nous utilisons $LPeg$ et Lua, aucune de ces deux méthodes ne sont possible dans le cadre de ce travail, il nous faut donc notre propre implémentation pour gérer les opérateurs binaires étant déclarés comme étant associatifs à gauche.
\subsubsection{Implémentation}
$LPeg$ nous permet de déclarer des fonctions de capture pour ce qui est lu par l'analyseur généré. Supposons la grammaire suivante: \\ \\
\begin{math}
S \rightarrow number \ \textrm{'}+\textrm{'} \ (S \ | \ number) \\
number \rightarrow [0-9]+
\end{math} \\ \\
Notre fonction de capture pour le modèle qui suit $S$ recevra simplement les arguments $gauche$, $repr\acute{e}sentation \ de \ l'op\acute{e}rateur$, $droite$. Déclarons d'abord la fonction comme ceci:
\begin{minted}{lua}
function left_assoc(left, op, right)
  return { left = left, op = op, right = right }
end
\end{minted}
Une analyse de l'entrée \mint{lua}{1 + 2 + 3} \noindent nous retournera donc la table \mint{lua}{{ left = 1, op = +, right = { left = 2, op = +, right = 3 } }}
\noindent Si on veut avoir l'associativité gauche, ce résultat est évidemment faux.
\newpage
\noindent[1]: Parsing Expression Grammars Made Practical, Nicolas Laurent \newline
[2]: Direct Left-Recursive Parsing Expression Grammars, Laurence Tratt

\end{document}