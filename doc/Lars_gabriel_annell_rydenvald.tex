\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[margin=3cm, tmargin=2cm, bmargin=2cm]{geometry}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{url}
\usepackage{gensymb}
\usepackage{caption}
\usepackage{subcaption}
\expandafter\def\csname ver@subfig.sty\endcsname{}
\usepackage{subfig}
\usepackage{minted}
\usepackage[hidelinks]{hyperref}
\setminted[java]{tabsize=2}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[l]{\small Lars Gabriel \linebreak Annell Rydenvald}
\fancyhead[c]{
	UNIGE \linebreak
}
\fancyhead[R]{Faculté des Sciences \linebreak Département d'informatique}
\fancyfoot[C]{
	\thepage
}

\lstset{
	basicstyle=\ttfamily
}

\captionsetup[subfigure]{labelformat=empty}


\begin{document}
\begin{center}
	\huge 
	Ardoises \\
	Formalismes et expressions
\end{center}
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage

\section{Introduction}
%Le but de ce travail, dans le cadre du logiciel \underline{\href{https://ardoises.ovh/overview}{Ardoises}}, est d'ajouter des formalismes pour les opérateurs ainsi qu'une manière de transformer 
\section{Ardoises}
% Ecrire à propos d'ardoises, et des autres logiciels qui existent déjà (c.f. présentation)
\section{Formalismes des opérateurs}
% Formalismes des opérateurs
\section{Analyse grammaticale}
Nous avons pensé à deux solutions différentes pour effectuer l'analyse grammaticale:
\begin{enumerate}
	\item[1)] Utiliser des expressions régulières, qui seraient définies par l'utilisateur pour chaque opérateur.
	\item[2)] Générer une grammaire à partir de modèles prédéfinis pour différents types d'opérateurs.
\end{enumerate}
J'ai choisi d'utiliser la 2$^{\grave{e}me}$ méthode, car même si les expressions régulières auraient pû être un moyen "plus simple", elles posent un problème: les expressions arithmétiques incluant des parenthèses ne sont pas des langages réguliers, puisqu'on peut, en prenant un exemple simple, se retrouver dans un cas comme celui-ci: $\{(\textquoteleft(\textquoteleft^{n}\textquoteleft)\textquoteleft^{n})^{*}, n \ge 0 \}$
\subsection{Choix de l'outil}
Il existe plusieurs générateurs d'analyseurs lexicaux, tels que: \begin{enumerate}
	\item \underline{\href{http://www.antlr.org/about.html}{ANTLR}}, écrit en Java, générant un analyseur $LL(^*)$
	\item \underline{\href{http://dinosaur.compilertools.net/}{Flex/Bison}}, écrit en C, générant un analyseur $LALR(1)$
	\item \underline{\href{https://pegjs.org/}{PEGjs}}, écrit en JavaScript, générant un parser $PEG$
	\item \underline{\href{https://github.com/LuaDist/lpeg}{LPeg}}, écrit en C, compatible avec Lua, générant un parser $PEG$
	\item \underline{\href{https://github.com/pygy/LuLPeg}{LulPeg}}, écrit en Lua, générant aussi un parser $PEG$
\end{enumerate}
Puisque le projet est écrit en Lua, pour avoir une interopérabilité facile entre les définitions d'opérateurs et expressions, j'ai choisi d'utiliser LPeg. LulPeg a aussi été considéré, cependant celui-ci est beaucoup plus lent que LPeg. \\ \textit{TODO: Include justification.} \\ LPeg, par sa modularité, permet aussi de facilement générer une grammaire à partir des opérateurs définis par l'utilisateur.
\subsection{Algorithme de génération de grammaire}
Puisque nous ne connaissons pas en avance les opérateurs disponibles dans une expression, il est nécessaire de générer la grammaire à partir des opérateurs définis par l'utilisateur. \\
Supposons les opérateurs simples suivants:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
	\hline
	\textbf{Opérateur} & \textbf{Représentation} & \textbf{Priorité} &  \textbf{Type} & \textbf{Associativité}\\ \hline
	Addition & '+' & 11 & binaire & droite \\ \hline
	Soustraction & '-' & 11 & binaire & droite  \\ \hline
	Multiplication & '*' & 12 & binaire & droite  \\ \hline
	Division & '/' & 12 & binaire & droite  \\ \hline
	Exponentiel & '\textasciicircum' & 13 & binaire & droite  \\ \hline
	Négation    & '-'  & 14 & unaire préfixe & N/A  \\ \hline 
  nombre & [0-9]+ & 15 & litéral & N/A \\ \hline
\end{tabular}
\end{center}
Partons de ce que je vais appeler une "grammaire de base", construite comme ceci: \\ \\
\begin{math}
S \rightarrow S'
% \ \\
% P15 \rightarrow number \ | \ \textrm{'}(\textrm{'} \ S' \ \textrm{'})\textrm{'}
\end{math} \\ \\
On va ensuite rajouter un à un les opérateurs dans cette grammaire, de la manière  suivante:

\begin{enumerate}
	\item On trie la table des opérateurs, par priorité, dans l'ordre décroissant.
	\item Pour chaque type d'opérateur, on crée le pattern. Par exemple, l'opérateur binaire $Addition$ dans notre table, aura le pattern \\ $P11 \rightarrow \ P12 \ \textrm{'}+\textrm{'} \ (P12 \ | \ P11)$
	\item On rajoute le nouveau pattern crée dans la grammaire de base
\end{enumerate}
Pour finir, on se retrouve avec une grammaire comme celle-ci: \\ \\
\begin{math}
S \rightarrow S' \\
S' \rightarrow P11 \\
P11 \rightarrow Addition \ | \ Soustraction \ | \ P12 \\
P12 \rightarrow Division \ | \ Multiplication \ | \ P13 \\
P13 \rightarrow Exponentiel \ | \ P14 \\
P14 \rightarrow N\acute{e}gation \ | \ P15 \\
P15 \rightarrow nombre \ | \ \textrm{'}(\textrm{'} \ S' \ \textrm{'})\textrm{'}
\end{math} \\ \\
Puisque $LPeg$ génère un analyseur lexical de type $PEG$, il faut faire attention à l'ordre de déclaration de la grammaire pour avoir une précédence correcte.
\end{document}